/**
 * Export Service
 * Handles conversation exports in multiple formats (PDF, Markdown, JSON)
 */

import { supabase } from '@/lib/supabase';
import { jsPDF } from 'jspdf';

export interface ConversationExport {
  id: string;
  user_id: string;
  export_type: 'pdf' | 'markdown' | 'json';
  conversation_ids: string[];
  file_url?: string;
  file_size?: number;
  created_at: string;
  expires_at: string;
}

export interface ConversationData {
  id: string;
  user_message: string;
  bot_response: string;
  created_at: string;
  session_id?: string;
}

class ExportService {
  /**
   * Export conversations to PDF
   */
  async exportToPDF(conversations: ConversationData[]): Promise<Blob> {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;
    const maxWidth = pageWidth - 2 * margin;
    let yPosition = margin;

    // Title
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('FinGenie Conversation History', margin, yPosition);
    yPosition += 15;

    // Export date
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100);
    doc.text(`Exported on: ${new Date().toLocaleString()}`, margin, yPosition);
    yPosition += 10;

    // Separator
    doc.setDrawColor(0, 128, 128);
    doc.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Conversations
    conversations.forEach((conv, index) => {
      // Check if we need a new page
      if (yPosition > pageHeight - 40) {
        doc.addPage();
        yPosition = margin;
      }

      // Conversation number and date
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(0);
      doc.text(`Conversation ${index + 1}`, margin, yPosition);
      
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(100);
      const date = new Date(conv.created_at).toLocaleString();
      doc.text(date, pageWidth - margin - doc.getTextWidth(date), yPosition);
      yPosition += 8;

      // User message
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(0, 100, 150);
      doc.text('You:', margin, yPosition);
      yPosition += 6;

      doc.setFont('helvetica', 'normal');
      doc.setTextColor(0);
      const userLines = doc.splitTextToSize(conv.user_message, maxWidth);
      doc.text(userLines, margin + 5, yPosition);
      yPosition += userLines.length * 5 + 5;

      // Bot response
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(0, 128, 128);
      doc.text('FinGenie:', margin, yPosition);
      yPosition += 6;

      doc.setFont('helvetica', 'normal');
      doc.setTextColor(0);
      const botLines = doc.splitTextToSize(conv.bot_response, maxWidth);
      doc.text(botLines, margin + 5, yPosition);
      yPosition += botLines.length * 5 + 10;

      // Separator
      if (index < conversations.length - 1) {
        doc.setDrawColor(200);
        doc.line(margin, yPosition, pageWidth - margin, yPosition);
        yPosition += 10;
      }
    });

    // Footer on last page
    const totalPages = doc.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(
        `Page ${i} of ${totalPages}`,
        pageWidth / 2,
        pageHeight - 10,
        { align: 'center' }
      );
    }

    return doc.output('blob');
  }

  /**
   * Export conversations to Markdown
   */
  async exportToMarkdown(conversations: ConversationData[]): Promise<Blob> {
    let markdown = '# FinGenie Conversation History\n\n';
    markdown += `**Exported on:** ${new Date().toLocaleString()}\n\n`;
    markdown += `**Total Conversations:** ${conversations.length}\n\n`;
    markdown += '---\n\n';

    conversations.forEach((conv, index) => {
      const date = new Date(conv.created_at).toLocaleString();
      
      markdown += `## Conversation ${index + 1}\n\n`;
      markdown += `*${date}*\n\n`;
      markdown += `**You:** ${conv.user_message}\n\n`;
      markdown += `**FinGenie:** ${conv.bot_response}\n\n`;
      markdown += '---\n\n';
    });

    markdown += `\n*Generated by FinPath Insight - Your AI Financial Assistant*\n`;

    return new Blob([markdown], { type: 'text/markdown' });
  }

  /**
   * Export conversations to JSON
   */
  async exportToJSON(conversations: ConversationData[]): Promise<Blob> {
    const exportData = {
      exported_at: new Date().toISOString(),
      total_conversations: conversations.length,
      conversations: conversations.map(conv => ({
        id: conv.id,
        timestamp: conv.created_at,
        user_message: conv.user_message,
        bot_response: conv.bot_response,
        session_id: conv.session_id
      }))
    };

    return new Blob([JSON.stringify(exportData, null, 2)], { 
      type: 'application/json' 
    });
  }

  /**
   * Download blob as file
   */
  downloadFile(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Export conversations with selected format
   */
  async exportConversations(
    conversations: ConversationData[],
    format: 'pdf' | 'markdown' | 'json'
  ): Promise<void> {
    try {
      let blob: Blob;
      let filename: string;
      const timestamp = new Date().toISOString().split('T')[0];

      switch (format) {
        case 'pdf':
          blob = await this.exportToPDF(conversations);
          filename = `fingenie-conversations-${timestamp}.pdf`;
          break;
        case 'markdown':
          blob = await this.exportToMarkdown(conversations);
          filename = `fingenie-conversations-${timestamp}.md`;
          break;
        case 'json':
          blob = await this.exportToJSON(conversations);
          filename = `fingenie-conversations-${timestamp}.json`;
          break;
        default:
          throw new Error('Unsupported export format');
      }

      // Save export record to database
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        await supabase.from('conversation_exports').insert({
          user_id: user.id,
          export_type: format,
          conversation_ids: conversations.map(c => c.id),
          file_size: blob.size
        });
      }

      // Download file
      this.downloadFile(blob, filename);
    } catch (error) {
      console.error('Error exporting conversations:', error);
      throw error;
    }
  }

  /**
   * Get export history
   */
  async getExportHistory(): Promise<ConversationExport[]> {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return [];

      const { data, error } = await supabase
        .from('conversation_exports')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(20);

      if (error) {
        console.error('Error fetching export history:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getExportHistory:', error);
      return [];
    }
  }

  /**
   * Share conversation via URL
   */
  async shareConversation(conversationId: string): Promise<string> {
    // Generate shareable link
    const baseUrl = window.location.origin;
    const shareUrl = `${baseUrl}/shared/conversation/${conversationId}`;
    
    // Copy to clipboard
    await navigator.clipboard.writeText(shareUrl);
    
    return shareUrl;
  }

  /**
   * Share multiple conversations
   */
  async shareConversations(conversationIds: string[]): Promise<string> {
    const baseUrl = window.location.origin;
    const shareUrl = `${baseUrl}/shared/conversations?ids=${conversationIds.join(',')}`;
    
    await navigator.clipboard.writeText(shareUrl);
    
    return shareUrl;
  }
}

export const exportService = new ExportService();
